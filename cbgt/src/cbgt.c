// gcc -o test/sim cbgt.c rando2.h -lm
// or
// gcc -o test/sim cbgt.c rando2.h -lm -std=c99
//
// ./sim -ns -n# -s#


//###########################################
// BG_inh_pathway.c:
//
// modified from S. Fusi and CC LO
//
// used with permission and modified by M Clapp
//
//###########################################


/* How to add a new variable: 1) add it to the proper structure and make a copy in the
description structure 2) DescribeNetwork should initialize the description structure
3) GenerateNetwork should initialize the variable for each neuron/synapse


CAUTION: no saturation on external NMDA!!!
*/

#include <stdio.h>
#include <stdlib.h>
#include <math.h>
#include <string.h>
#include <stdarg.h>
#include "rando2.h"


/*
Some stuff from Numerical Recipes
*/

#define IA 16807
#define IM 2147483647
#define AM (1.0/IM)
#define IQ 127773
#define IR 2836
#define NTAB 32
#define NDIV (1+(IM-1)/NTAB)
#define EPS 1.2e-7
#define RNMX (1.0-EPS)
//#define PI 3.141592654

long *idum;

void sran1(long *iseed)
{
  idum = iseed;
}

float ran1()
{
  int j;
  long k;
  static long iy=0;
  static long iv[NTAB];
  float temp;

  if (*idum <= 0 || !iy) {
    if (-(*idum) < 1) *idum=1;
    else *idum = -(*idum);
    for (j=NTAB+7;j>=0;j--) {
      k=(*idum)/IQ;
      *idum=IA*(*idum-k*IQ)-IR*k;
      if (*idum < 0) *idum += IM;
      if (j < NTAB) iv[j] = *idum;
    }
    iy=iv[0];
  }
  k=(*idum)/IQ;
  *idum=IA*(*idum-k*IQ)-IR*k;
  if (*idum < 0) *idum += IM;
  j=iy/NDIV;
  iy=iv[j];
  iv[j] = *idum;
  if ((temp=AM*iy) > RNMX) return RNMX;
  else return temp;
}


float gasdev()
{
  float ran1();
  static int iset=0;
  static float gset;
  float fac,rsq,v1,v2;

  if  (iset == 0) {
    do {
      v1=2.0*ran1()-1.0;
      v2=2.0*ran1()-1.0;
      rsq=v1*v1+v2*v2;
    } while (rsq >= 1.0 || rsq == 0.0);
    fac=sqrt(-2.0*log(rsq)/rsq);
    gset=v1*fac;
    iset=1;
    return v2*fac;
  } else {
    iset=0;
    return gset;
  }
}


//Below is the real stuff


#define MAXTN 10000 // max number of target neurons

// types of receptors

#define MAXRECEPTORS 4

#define AMPA 0
#define GABA 1
#define NMDA 2
// #define DPMN 3

// =============================================================
// Structures for the simulation

// utility structures

typedef struct {
  char *string;
  float *variable;
} PairFloat;

// --------------------- SYNAPSE structure ---------------------

typedef struct {
  int TargetPop;
  int TargetNeuron;
  float Efficacy; // change in the conductance due to a single spike (nS) (hence it is always positive, IPSP come out from rev pots)
  float LastConductance; // synaptic conductance when the last spike was emitted (useful for NMDA saturation), -1 if not NMDA (and hence no saturation)
  int TargetReceptor; // 0=AMPA, 1=NMDA, 2=GABA
} Synapse;

// --------------------- NEURON structure -----------------------


typedef struct {

  // outputs

  int Naxonals;    // axonal tree (total number of synapses on the axon)
  Synapse *Axonals;

  // inputs

  int Nreceptors;
  float Tau[MAXRECEPTORS]; // tau for each conductance
  float LS[MAXRECEPTORS]; // total conductance for internal inputs (spikes generated by the network)
  float RevPots[MAXRECEPTORS]; // reversal potentials
  int   MgFlag[MAXRECEPTORS]; // 1 is magnesium block is active, 0 otherwise

  // external gaussian inputs for each receptor (to be added to S at each time step)
  float ExtS[MAXRECEPTORS]; // nS

  float ExtMuS[MAXRECEPTORS]; // nS/s
  float ExtSigmaS[MAXRECEPTORS]; // nS/s^2

  // here I should consider also the external inputs!!!

  // dynamic variables

  float V;
  int RefrState; // Refractory state counter
  float C; // capacitance in nF
  float Taum; // membrane time constant
  float RestPot; // Resting potential
  float ResetPot; // reset potential
  float Threshold; // threhsold

  // Spike-frequency adaptation.
  // The properties of calcium-activated potassium current I

  float Ca;  //Concentration of Ca ions
  float Vk;  // resting potential
  float alpha_ca; // Amount of increment of [Ca] with each spike discharge. (muM)
  float tau_ca; // time constant
  float g_ahp; // efficacy

  // the times of the last two spikes
  float TimeLastSpike; // time of the last emitted spike (for NMDA saturation)
  float PTimeLastSpike;



  //Anomalous delayed rectifier (ADR). Simulating the up and down state in striatal neurons.
  float g_adr_max;  //Maximun value of the g
  float Vadr_h; //Potential for g_adr=0.5g_adr_max
  float Vadr_s; //Slop of g_adr at Vadr_h, defining how sharp the shape of g_ard is.
  float ADRRevPot; //reverse potential for ADR.
  float g_k_max;  // Maximun outward rectifying current
  float Vk_h; //Potential for g_k=0.5g_k_max
  float Vk_s; //Slop of g_k at Vk_h, defining how sharp the shape of g_k is.
  float tau_k_max; //maximum value of tau_k
  float n_k;  // gating variable for outward rectifying K channel;

  float tauhm;
  float tauhp;
  float V_T;
  float V_h;
  float g_T;
  float h; // gating variable for burst;

  // dopaminergic learning
  int dpmn_type;      // 0 = none, 1 = D1, 2 = D2
  int dpmn_cortex;    // 0 = not cortex, 1 = cortex
  float dpmn_alphaw;  // for weight
  float dpmn_dPRE;
  float dpmn_dPOST;
  float dpmn_tauE;    // eligibility trace decay
  float dpmn_tauPRE;
  float dpmn_tauPOST;
  float dpmn_c;       // parameter for f(DA)
  float dpmn_wmax;    // maximum weight
  float dpmn_taug;    // not used, is supposed to be conductance decay
  float dpmn_Q1;      // expected reward of action 1
  float dpmn_alpha;   // learning rate
  float dpmn_APRE;
  float dpmn_APOST;
  float dpmn_E;       // eligibility trace
  float dpmn_w;       // weight
  float dpmn_XPRE;
  float dpmn_XPOST;
  float dpmn_DAp;     // phasic dopamine
  float dpmn_tauDOP;
  float dpmn_DAt;     // tonic dopamine
  float dpmn_a;       // parameter for f(DA)
  float dpmn_b;       // parameter for f(DA)
  float dpmn_m;       // motivation, modulates strength of dopamne level
  float dpmn_taum;    // decay of motivation
  float dpmn_Q2;      // expected reward of action 2

} Neuron;



// ------------------- Population structure ---------------------
#define MAXDELAYINDT 50
#define MAXSPIKESINDT 2000

typedef struct {
  char Label[100];

  int Ncells;
  Neuron *Cell;

  // Table of spikes emitted by the neurons of this population
  int CTableofSpikes; // pointer where we are (time t)
  int DTableofSpikes; // pointer to the t-delay
  int NTableofSpikes[MAXDELAYINDT];
  int TableofSpikes[MAXDELAYINDT][MAXSPIKESINDT];

} Population;

#define MAXP 32 // max number of populations
#define MAXEXTMEM 20

int Npop;
Population Pop[MAXP];

// global variables for the simulation

float dt = 0.2;      // in ms
float Time;    // absolute time from the beginning of the trial
float dpmn_RewardTime; // time at which reward is applied, which is decision time + 300
int delayindt = 1; // transmission delay in dt
int flagverbose=1; // flag to activate verbose messages
int FlagSaveAllSpikes=1;
//? float ext_freq; // external noise
// =================================================================
// Descriptors to generate the network structure

typedef struct {
  float Connectivity; // mean fraction of randomly connected target neurons
  float TargetReceptor; // 0=AMPA, ...
  float MeanEfficacy; // mean efficacy (for initialization)
  float EfficacySD; // Standard deviation of the efficacy distribution.
} SynPopDescr;

typedef struct {
  char Label[100];
  int Ncells;

  int NTargetPops;
  int TargetPops[MAXP];

  SynPopDescr SynP[MAXP];

  int Nreceptors;
  char  ReceptorLabel[MAXRECEPTORS][100]; // label for the receptor (needed for the compiler)
  float Tau[MAXRECEPTORS]; // tau for each conductance
  float RevPots[MAXRECEPTORS]; // reversal potentials
  int   MgFlag[MAXRECEPTORS]; // magnesium block flag

  // external input (externally defined)
  float MeanExtCon[MAXRECEPTORS]; // mean total number of external connections
  float MeanExtEff[MAXRECEPTORS]; // external mean efficacy
  float ExtEffSD[MAXRECEPTORS]; // Deviation of distribution of external efficacy
  float FreqExt[MAXRECEPTORS]; // external frequency in Hz
  float FreqExtSD[MAXRECEPTORS]; // external frequency in Hz
  //? float FreqExtMem[MAXRECEPTORS]; // memory in the external noise
  float FreqExtDecay[MAXRECEPTORS]; //decay factor of the external noise
  //? float FreqExtNorm[MAXRECEPTORS]; //Normalization factor for the memory of the external noise

  // external input (statistics internally calculated)
  float MeanExtMuS[MAXRECEPTORS]; // statistics of the external input nS/s
  float MeanExtSigmaS[MAXRECEPTORS];
  // dynamic variables

  float C; // capacitance
  float Taum; // membrane time constant
  float RestPot; // Resting potential
  float ResetPot; // reset potential
  float Threshold; // threhsold

  float Vk;  // resting potential
  float alpha_ca; // Amount of increment of [Ca] with each spike discharge. (muM)
  float tau_ca; // time constant
  float g_ahp; // efficacy

  //Anomalous delayed rectifier (ADR)
  float g_adr_max;  //Maximun value of the g
  float Vadr_h; //Potential for g_adr=0.5g_adr_max
  float Vadr_s; //Slop of g_adr at Vadr_h, defining how sharp the shape of g_ard is.
  float ADRRevPot; //Reverse potential for ADR
  float g_k_max;  // Maximun outward rectifying current
  float Vk_h; //Potential for g_k=0.5g_k_max
  float Vk_s; //Slop of g_k at Vk_h, defining how sharp the shape of g_k is.
  float tau_k_max; //maximum tau for outward rectifying k current

  float tauhm;
  float tauhp;
  float V_T;
  float V_h;
  float g_T;
  float h;

  // dopaminergic learning
  int dpmn_type; // 0 = none, 1 = D1, 2 = D2
  int dpmn_cortex;    // 0 = not cortex, 1 = cortex
  float dpmn_alphaw;
  float dpmn_dPRE;
  float dpmn_dPOST;
  float dpmn_tauE;
  float dpmn_tauPRE;
  float dpmn_tauPOST;
  float dpmn_c;
  float dpmn_wmax;
  float dpmn_taug;
  float dpmn_Q1;
  float dpmn_alpha;
  float dpmn_APRE;
  float dpmn_APOST;
  float dpmn_E;
  float dpmn_w;
  float dpmn_XPRE;
  float dpmn_XPOST;
  float dpmn_DAp;
  float dpmn_tauDOP;
  float dpmn_DAt;
  float dpmn_a;
  float dpmn_b;
  float dpmn_m;
  float dpmn_taum;
  float dpmn_Q2;

} PopDescr;

PopDescr PopD[MAXP];

// ===============================================================
// Protocol descriptors

#define MAXSTAGES 1024 // for multistage simulations
#define MAXEVENTS 32 // max events per stage

#define ENDOFTRIAL 1
#define CHANGEEXTFREQ 2
#define CHANGEMEANEFF 3
#define CHANGEEXTFREQSD 4
#define RESETEXTFREQ 5

typedef struct {
  int Type;
  float ETime;
  int PopNumber;
  int TargetPopNumber;
  int ReceptorNumber;
  float FreqExt;
  float FreqExtSD;
  float MeanEff;
  char Label[100];
  int RewardFlag;
  float RewardVal;
} EventDescr;

int NEvents=0;
int CEvent; // current event
float NextEventTime=0.;
EventDescr Events[MAXSTAGES][MAXEVENTS];

// dynamic cutoff
int NCutoffs=0;
int CCutoff;
EventDescr Cutoffs[MAXSTAGES][MAXEVENTS];

// staging
int NStages = 0;
int CStage = 0;
int CStageStart = 0;

// dopaminergic learning
EventDescr EndingEvent; // keep track of which event (AKA which dynamic threshold) was triggered
int rewardflag; // whether or not to give a reward on the next time step

// Multitrial version:

int CurrentTrial;
int Trialnumber; //given from command line.
int NumberofTrials;


// ===============================================================================
// AUXILIARY SUBROUTINES
// ===============================================================================

/* --------------------------------------------------------------------------------
   Report: prints on screen and log file (dev_oss filename device)
   -------------------------------------------------------------------------------- */

void report(char *fmt,...)
{
  static FILE *devlog;
  static int initflag=1;
  va_list ap;
  char *s,fmtemp[20];
  int ival,fmtemp_i;
  float fval;
  char *cval;

  if(initflag) {
    devlog=fopen("simu.log","w");
    if(devlog==NULL) return;
    initflag=0;
  }

  va_start(ap,fmt);
  for(s=fmt; *s; s++) {

    if(*s!='%') { if(flagverbose) printf("%c",*s); fprintf(devlog,"%c",*s); continue; }

    fmtemp_i=0; while (*s && !(*s=='s' || *s=='d' || *s=='f')) { fmtemp[fmtemp_i]=*s; s++; fmtemp_i++; }
    if(*s=='d') {  ival=va_arg(ap,int); fmtemp[fmtemp_i]='d'; fmtemp[fmtemp_i+1]=0;
                   if(flagverbose) printf(fmtemp,ival); fprintf(devlog,fmtemp,ival);  }
    if(*s=='f') {  fval=va_arg(ap,double); fmtemp[fmtemp_i]='f'; fmtemp[fmtemp_i+1]=0;
                   if(flagverbose) printf(fmtemp,fval); fprintf(devlog,fmtemp,fval);  }
    if(*s=='s') {  cval=va_arg(ap,char *); fmtemp[fmtemp_i]='s'; fmtemp[fmtemp_i+1]=0;
                   if(flagverbose) printf(fmtemp,cval); fprintf(devlog,fmtemp,cval);  }
  } /* end for */
  va_end(ap);
}



// ===============================================================
//
// INPUT
// ==============================================================
// auxiliary subroutines for parsing the descriptor file
// returns the code of the population with name s (-1 in case of error)

int PopulationCode(char *s)
{
  int p;


  for (p=0; p<Npop; p++) {
    if (strcmp(PopD[p].Label,s) == 0) {
      return p;
    }
  }
  return -1;
}


// returns the code of the receptor with name s for pop p (-1 in case of error)

int ReceptorCode(char *s,int p)
{
  int r;

  for (r=0; r<PopD[p].Nreceptors; r++) {
    if (strcmp(PopD[p].ReceptorLabel[r],s) == 0) {
      return r;
    }
  }
  return -1;
}

// =======================================================================
// DescribeNetwork()
// Initializes the descriptors of the network by parsing cl_network.conf
// =======================================================================

#define EXC 0
#define INH 1


int DescribeNetwork() {
  FILE* devconf;
  char buf[1000], *s, *es;
  int currentpopflag = 0;
  int currentreceptorflag = 0;
  int line, auxi;
  int currentpop, currentreceptor, currenttarget;
  float aux;
  float std_p, std_tau;
  int flag_d;

  // FIRST PASSAGE
  // -------------------------------------------------------------------
  // the parser has to go over the file twice: the first time reads all
  // the labels and initializes the number of populations and the number
  // of receptors
  report("Parsing network configuration... first passage\n");

  /*  strncpy=(network_conf,prefix,strlen(prefix));
  strcpy=(network_conf+strlen(prefix),"network.conf");
  devconf=fopen(network_conf,"r");*/
  devconf = fopen("network.conf", "r");
  if (devconf == NULL) {
    printf("ERROR:  Unable to read configuration file\n");
    return 0;
  }

  Npop = 0;
  line = -1;

  while (fgets(buf, 1000, devconf) != NULL) {
    line++;
    s = buf;
    // trim \n at the end
    es = buf;
    while (*es && *es != '\n') es++;
    *es = 0;

    while (*s == ' ' || *s == '\t') s++;  // skip blanks
    if (*s == 0) continue;                // empty line
    if (*s == '%') continue;              // remark

    // commands for defining a new population
    if (strncmp(s, "NeuralPopulation:", 17) == 0) {
      currentpopflag = 1;
      s += 17;
      while (*s == ' ') s++;
      strcpy(PopD[Npop].Label, s);
      report("Population: %s\n", PopD[Npop].Label);
      PopD[Npop].Nreceptors = 0;
      continue;
    }

    if (strncmp(s, "EndNeuralPopulation", 19) == 0) {
      currentpopflag = 0;
      Npop++;
      continue;
    }

    // command for defining a receptor
    if (strncmp(s, "Receptor:", 9) == 0) {
      currentreceptorflag = 1;
      s += 9;
      while (*s == ' ') s++;
      strcpy(PopD[Npop].ReceptorLabel[PopD[Npop].Nreceptors], s);
      report("Receptor %d: %s\n", PopD[Npop].Nreceptors,
             PopD[Npop].ReceptorLabel[PopD[Npop].Nreceptors]);
    }

    if (strncmp(s, "EndReceptor", 11) == 0) {
      currentreceptorflag = 0;
      PopD[Npop].Nreceptors++;
    }
  }

  fclose(devconf);

  // Second passage: now all the parameters and the target populations are
  // parsed
  // ----------------------------------------------------------------------------

  report("Parsing network configuration... second passage\n");

  //  devconf=fopen(network_conf,"r");
  devconf = fopen("network.conf", "r");
  if (devconf == NULL) {
    printf("ERROR:  Unable to read configuration file\n");
    return 0;
  }

  line = -1;

  while (fgets(buf, 1000, devconf) != NULL) {
    line++;
    s = buf;

    // trim \n at the end
    es = buf;
    while (*es && *es != '\n') es++;
    *es = 0;

    while (*s == ' ' || *s == '\t') s++;  // skip blanks
    if (*s == 0) continue;                // empty line
    if (*s == '%') continue;              // remark

    // population commands
    if (strncmp(s, "NeuralPopulation:", 17) == 0) {
      currentpopflag = 1;
      s += 17;
      while (*s == ' ') s++;
      currentpop = PopulationCode(s);
      if (currentpop == -1) {
        printf("Unknown population [%s]: line %d\n", s, line);
        return -1;
      }
      PopD[currentpop].NTargetPops = 0;
      report(
          "-----------------------------------\n    Population: "
          "%s\n-----------------------------------\n",
          PopD[currentpop].Label);

      // Initialize some population parameters

      PopD[currentpop].g_adr_max = 0;
      PopD[currentpop].Vadr_h = -100;
      PopD[currentpop].Vadr_s = 10;
      PopD[currentpop].ADRRevPot = -90;
      PopD[currentpop].g_k_max = 0;
      PopD[currentpop].Vk_h = -34;
      PopD[currentpop].Vk_s = 6.5;
      PopD[currentpop].tau_k_max = 8;

      PopD[currentpop].tauhm = 20;
      PopD[currentpop].tauhp = 100;
      PopD[currentpop].V_h = -60;
      PopD[currentpop].V_T = 120;
      PopD[currentpop].g_T = 0.0;
      continue;
    }

    if (strncmp(s, "EndNeuralPopulation", 19) == 0) {
      report("EndPopulation\n");
      currentpopflag = 0;
      continue;
    }

    // parameters for the population
    if (currentpopflag) {

      int paramnum;
      int found;
      found = 0;

      if (strncmp(s, "N=", 2) == 0) {
        PopD[currentpop].Ncells = atoi(s + 2);
        report("  N=%d\n", PopD[currentpop].Ncells);
        continue;
      }

      //int dpmn_type; // 0 = none, 1 = D1, 2 = D2
      if (strncmp(s, "dpmn_type=", 10) == 0) {
        PopD[currentpop].dpmn_type = atoi(s + 10);
        report("  dpmn_type=%d\n", PopD[currentpop].dpmn_type);
        continue;
      }

      //int dpmn_cortex;    // 0 = not cortex, 1 = cortex
      if (strncmp(s, "dpmn_cortex=", 12) == 0) {
        PopD[currentpop].dpmn_cortex = atoi(s + 12);
        report("  dpmn_cortex=%d\n", PopD[currentpop].dpmn_cortex);
        continue;
      }

      // only float parameters, because array can only hold one type
      PairFloat popparams[128];
      popparams[0] = (PairFloat){"C", &PopD[currentpop].C}; // (nF)
      popparams[1] = (PairFloat){"Taum", &PopD[currentpop].Taum}; // membrane time constant (ms)
      popparams[2] = (PairFloat){"RestPot", &PopD[currentpop].RestPot}; // resting potential (mV)
      popparams[3] = (PairFloat){"ResetPot", &PopD[currentpop].ResetPot}; // reset potential (mV)
      popparams[4] = (PairFloat){"Threshold", &PopD[currentpop].Threshold}; // (mV)
      popparams[5] = (PairFloat){"RestPot_ca", &PopD[currentpop].Vk}; // (mV)
      popparams[6] = (PairFloat){"Alpha_ca", &PopD[currentpop].alpha_ca}; // (mV)
      popparams[7] = (PairFloat){"Tau_ca", &PopD[currentpop].tau_ca}; // (mV)
      popparams[8] = (PairFloat){"Eff_ca", &PopD[currentpop].g_ahp}; // (mV)
      popparams[9] = (PairFloat){"g_ADR_Max", &PopD[currentpop].g_adr_max}; // (mV)
      popparams[10] = (PairFloat){"V_ADR_h", &PopD[currentpop].Vadr_h}; // (mV)
      popparams[11] = (PairFloat){"V_ADR_s", &PopD[currentpop].Vadr_s}; // (mV)
      popparams[12] = (PairFloat){"ADRRevPot", &PopD[currentpop].ADRRevPot}; // (mV)
      popparams[13] = (PairFloat){"g_k_Max", &PopD[currentpop].g_k_max}; // (mV)
      popparams[14] = (PairFloat){"V_k_h", &PopD[currentpop].Vk_h}; // (mV)
      popparams[15] = (PairFloat){"V_k_s", &PopD[currentpop].Vk_s}; // (mV)
      popparams[16] = (PairFloat){"tau_k_max", &PopD[currentpop].tau_k_max}; // (mV)
      popparams[17] = (PairFloat){"tauhm", &PopD[currentpop].tauhm}; // (ms)
      popparams[18] = (PairFloat){"tauhp", &PopD[currentpop].tauhp}; // (ms)
      popparams[19] = (PairFloat){"V_h", &PopD[currentpop].V_h}; // (mV)
      popparams[20] = (PairFloat){"V_T", &PopD[currentpop].V_T}; // (mV)
      popparams[21] = (PairFloat){"g_T", &PopD[currentpop].g_T}; // (mS)
      // parameters for the population -- dopaminergic learning
      popparams[22] = (PairFloat){"dpmn_alphaw", &PopD[currentpop].dpmn_alphaw};
      popparams[23] = (PairFloat){"dpmn_dPRE", &PopD[currentpop].dpmn_dPRE};
      popparams[24] = (PairFloat){"dpmn_dPOST", &PopD[currentpop].dpmn_dPOST};
      popparams[25] = (PairFloat){"dpmn_tauE", &PopD[currentpop].dpmn_tauE};
      popparams[26] = (PairFloat){"dpmn_tauPRE", &PopD[currentpop].dpmn_tauPRE};
      popparams[27] = (PairFloat){"dpmn_tauPOST", &PopD[currentpop].dpmn_tauPOST};
      popparams[28] = (PairFloat){"dpmn_c", &PopD[currentpop].dpmn_c};
      popparams[29] = (PairFloat){"dpmn_wmax", &PopD[currentpop].dpmn_wmax};
      popparams[30] = (PairFloat){"dpmn_taug", &PopD[currentpop].dpmn_taug};
      popparams[31] = (PairFloat){"dpmn_Q1", &PopD[currentpop].dpmn_Q1};
      popparams[32] = (PairFloat){"dpmn_alpha", &PopD[currentpop].dpmn_alpha};
      popparams[33] = (PairFloat){"dpmn_APRE", &PopD[currentpop].dpmn_APRE};
      popparams[34] = (PairFloat){"dpmn_APOST", &PopD[currentpop].dpmn_APOST};
      popparams[35] = (PairFloat){"dpmn_E", &PopD[currentpop].dpmn_E};
      popparams[36] = (PairFloat){"dpmn_w", &PopD[currentpop].dpmn_w};
      popparams[37] = (PairFloat){"dpmn_XPRE", &PopD[currentpop].dpmn_XPRE};
      popparams[38] = (PairFloat){"dpmn_XPOST", &PopD[currentpop].dpmn_XPOST};
      popparams[39] = (PairFloat){"dpmn_DAp", &PopD[currentpop].dpmn_DAp};
      popparams[40] = (PairFloat){"dpmn_tauDOP", &PopD[currentpop].dpmn_tauDOP};
      popparams[41] = (PairFloat){"dpmn_DAt", &PopD[currentpop].dpmn_DAt};
      popparams[42] = (PairFloat){"dpmn_a", &PopD[currentpop].dpmn_a};
      popparams[43] = (PairFloat){"dpmn_b", &PopD[currentpop].dpmn_b};
      popparams[44] = (PairFloat){"dpmn_m", &PopD[currentpop].dpmn_m};
      popparams[45] = (PairFloat){"dpmn_taum", &PopD[currentpop].dpmn_taum};
      popparams[46] = (PairFloat){"dpmn_Q2", &PopD[currentpop].dpmn_Q2};

      for (paramnum = 0; paramnum < 47; paramnum++) {
        PairFloat param;
        param = popparams[paramnum];
        int length;
        length = strlen(param.string);
        if (strncmp(s, param.string, length) == 0
          && strncmp(s + length, "=", 1) == 0) {
          *(param.variable) = atof(s + length + 1); // +1 to take into account the "="
          report("  %s=%f\n", param.string, (double)*(param.variable));
          found = 1;
          break;
        }
      }
      if (found) {
        continue;
      }

      // receptor paramters
      if (strncmp(s, "Receptor:", 9) == 0) {
        currentreceptorflag = 1;
        s += 9;
        while (*s == ' ') s++;
        currentreceptor = ReceptorCode(s, currentpop);
        if (currentreceptor == -1) {
          printf("ERROR: Unknown receptor type\n");
          return -1;
        }
        if (strncmp(s, "NMDA", 4) ==
            0) {  // activate magnesium block for NMDA type
          PopD[currentpop].MgFlag[currentreceptor] = 1;
        } else
          PopD[currentpop].MgFlag[currentreceptor] = 0;
        report("Receptor %d: %s (Mg block: %d)\n", currentreceptor,
               PopD[currentpop].ReceptorLabel[currentreceptor],
               PopD[currentpop].MgFlag[currentreceptor]);

        PopD[currentpop].ExtEffSD[currentreceptor] = 0;
        PopD[currentpop].FreqExtSD[currentreceptor] = 0;
        continue;
      }

      if (currentreceptorflag) {

        PairFloat recparams[128];
        recparams[0] = (PairFloat){"Tau", &PopD[currentpop].Tau[currentreceptor]};
        recparams[1] = (PairFloat){"RevPot", &PopD[currentpop].RevPots[currentreceptor]}; // Reversal potential (mV)
        recparams[2] = (PairFloat){"FreqExt", &PopD[currentpop].FreqExt[currentreceptor]}; // Ext frequency (Hz)
        recparams[3] = (PairFloat){"FreqExtSD", &PopD[currentpop].FreqExtSD[currentreceptor]}; // Ext frequency SD (Hz)
        recparams[4] = (PairFloat){"MeanExtEff", &PopD[currentpop].MeanExtEff[currentreceptor]}; // Ext efficacy (nS)
        recparams[5] = (PairFloat){"ExtEffSD", &PopD[currentpop].ExtEffSD[currentreceptor]}; // Ext efficacy SD (nS)
        recparams[6] = (PairFloat){"MeanExtCon", &PopD[currentpop].MeanExtCon[currentreceptor]}; // Ext connections

        for (paramnum = 0; paramnum < 7; paramnum++) {
          PairFloat param;
          param = recparams[paramnum];
          int length;
          length = strlen(param.string);
          if (strncmp(s, param.string, length) == 0
            && strncmp(s + length, "=", 1) == 0) {
            *(param.variable) = atof(s + length + 1); // +1 to take into account the "="
            report("  %s=%f\n", param.string, (double)*(param.variable));
            found = 1;
            break;
          }
        }
        if (found) {
          continue;
        }

      } // currentreceptorflag

      // target populations
      if (strncmp(s, "TargetPopulation:", 17) == 0) {
        s += 17;
        while (*s == ' ') s++;
        currenttarget = PopulationCode(s);
        if (currenttarget == -1) {
          printf("Unknown target population: line %d\n", line);
          return -1;
        }
        PopD[currentpop].TargetPops[PopD[currentpop].NTargetPops] = currenttarget;

        report("Synapses targeting population: %s (%d)\n ",
               PopD[currenttarget].Label, currenttarget);

        PopD[currentpop].SynP[PopD[currentpop].NTargetPops].EfficacySD = 0;
        continue;
      }

      if (strncmp(s, "Connectivity=", 13) == 0) {
        aux = atof(s + 13);
        PopD[currentpop].SynP[PopD[currentpop].NTargetPops].Connectivity = aux;
        report("  Connectivity=%f\n", (double)aux);
      }
      if (strncmp(s, "TargetReceptor=", 15) == 0) {
        s += 15;
        while (*s == ' ' || *s == '\t') s++;
        auxi = ReceptorCode(s, currenttarget);
        if (auxi == -1) {
          printf("Unknown target receptor, line %d\n", line);
          return -1;
        }
        PopD[currentpop].SynP[PopD[currentpop].NTargetPops].TargetReceptor = auxi;
        report("  Target receptor code=%d\n", auxi);
      }

      if (strncmp(s, "MeanEff=", 8) == 0) {
        aux = atof(s + 8);
        PopD[currentpop].SynP[PopD[currentpop].NTargetPops].MeanEfficacy = aux;
        report("  Mean efficacy=%f\n", (double)aux);
      }
      if (strncmp(s, "EffSD=", 6) == 0) {
        aux = atof(s + 6);
        PopD[currentpop].SynP[PopD[currentpop].NTargetPops].EfficacySD = aux;
        report("  Efficacy SD=%f\n", (double)aux);
      }
    } // currentpopflag

    if (strncmp(s, "EndReceptor", 11) == 0) {
      currentreceptorflag = 0;
      continue;
    }

    // target populations

    if (strncmp(s, "EndTargetPopulation", 20) == 0) {
      PopD[currentpop].NTargetPops++;
      continue;
    }

  }  // end while

  fclose(devconf);

  return 1;
}


// -------------------------------------------------------------------------------------
// Parse protocol
// -------------------------------------------------------------------------------------

int ParseProtocol() {
  FILE *devprot;
  char buf[1000], *s, *es;
  int eventflag = 0;
  int line, auxi, currentpop;
  float aux;

  report(
      "-------------------------------------------------\nParsing "
      "protocol...\n");

  /*  strncpy=(network_pro,prefix,strlen(prefix));
  strcpy=(network_pro+strlen(prefix),"network.pro");
  devconf=fopen(network_pro,"r");*/
  devprot = fopen("network.pro", "r");
  if (devprot == NULL) {
    printf("ERROR:  Unable to read protocol file\n");
    return 0;
  }

  line = -1;
  NEvents = 0;
  NCutoffs = 0;
  NStages = 0;

  while (fgets(buf, 1000, devprot) != NULL) {
    line++;
    s = buf;
    // trim \n at the end
    es = buf;
    while (*es && *es != '\n') es++;
    *es = 0;

    while (*s == ' ' || *s == '\t') s++;  // skip blanks
    if (*s == 0) continue;                // empty line
    if (*s == '%') continue;              // remark

    // commands for defining a new event
    if (strncmp(s, "EventTime", 9) == 0) {
      eventflag = 1;
      s += 9;
      Events[NStages][NEvents].ETime = atof(s);
      if (Events[NStages][NEvents].ETime < 0.) {
        printf("ERROR: Invalid event time, line %d\n", line);
        return -1;
      }

      report("Event %d: time %f ms\n", NEvents, Events[NStages][NEvents].ETime);
      continue;
    }

    if (strncmp(s, "EndEvent", 8) == 0) {
      if (Events[NStages][NEvents].Type == ENDOFTRIAL) {
        if (Events[NStages][NEvents].PopNumber >= 0) {
          // dynamic cutoff
          Cutoffs[NStages][NCutoffs] = Events[NStages][NEvents];
          NCutoffs++;
          NEvents++;
        } else {
          NStages++;
          NEvents = 0;
          NCutoffs = 0;
        }
      } else {
        NEvents++;
      }
      eventflag = 0;
      continue;
    }

    if (strncmp(s, "Type=", 5) == 0) {
      s += 5;
      while (*s == ' ' || *s == '\t') s++;
      if (strncmp(s, "ResetExtFreq", 12) == 0) {
        Events[NStages][NEvents].Type = RESETEXTFREQ;
      }
      if (strncmp(s, "ChangeExtFreq", 13) == 0) {
        Events[NStages][NEvents].Type = CHANGEEXTFREQ;
      }
      if (strncmp(s, "ChangeExtFreqSD", 15) == 0) {
        Events[NStages][NEvents].Type = CHANGEEXTFREQSD;
      }
      if (strncmp(s, "ChangeMeanEff", 13) == 0) {
        Events[NStages][NEvents].Type = CHANGEMEANEFF;
      }
      if (strncmp(s, "EndTrial", 8) == 0) {
        Events[NStages][NEvents].Type = ENDOFTRIAL;
        Events[NStages][NEvents].PopNumber = -1;
      }
      continue;
    }

    if (strncmp(s, "FreqExt=", 8) == 0) {
      s += 8;
      Events[NStages][NEvents].FreqExt = atof(s);
      report("  New external frequency: %f Hz\n", Events[NStages][NEvents].FreqExt);
      continue;
    }
    if (strncmp(s, "FreqExtSD=", 10) == 0) {
      s += 10;
      Events[NStages][NEvents].FreqExtSD = atof(s);
      report("  New external frequency SD: %f Hz\n", Events[NStages][NEvents].FreqExtSD);
      continue;
    }

    if (strncmp(s, "MeanEff=", 8) == 0) {
      s += 8;
      Events[NStages][NEvents].MeanEff = atof(s);
      report("  New Mean Eff: %f Hz\n", Events[NStages][NEvents].MeanEff);
      continue;
    }

    if (strncmp(s, "Label=", 6) == 0) {
      s += 6;
      strcpy(Events[NStages][NEvents].Label, s);
      report("   Label: [%s]\n", Events[NStages][NEvents].Label);
      continue;
    }

    if (strncmp(s, "Population:", 11) == 0 && eventflag) {
      s += 11;
      while (*s == ' ') s++;
      currentpop = PopulationCode(s);
      if (currentpop == -1) {
        printf("ERROR: Unknown population: line %d\n", line);
        return -1;
      }
      Events[NStages][NEvents].PopNumber = currentpop;
      report("  Population code: %d\n", currentpop);
      continue;
    }

    if (strncmp(s, "TargetPopulation:", 17) == 0 && eventflag) {
      s += 17;
      while (*s == ' ') s++;
      currentpop = PopulationCode(s);
      if (currentpop == -1) {
        printf("ERROR: Unknown population: line %d\n", line);
        return -1;
      }
      Events[NStages][NEvents].TargetPopNumber = currentpop;
      report("  TargetPopulation code: %d\n", currentpop);
      continue;
    }

    if (strncmp(s, "Receptor:", 9) == 0 && eventflag) {
      s += 9;
      while (*s == ' ' || *s == '\t') s++;
      auxi = ReceptorCode(s, currentpop);
      if (auxi == -1) {
        printf("ERROR: Unknown receptor, line %d\n", line);
        return -1;
      }
      Events[NStages][NEvents].ReceptorNumber = auxi;
      report("  Receptor code:%d\n", auxi);
    }

    if (strncmp(s, "RewardFlag=", 11) == 0) {
      s += 11;
      Events[NStages][NEvents].RewardFlag = atoi(s);
      report("  Reward Flag: %d\n", Events[NStages][NEvents].RewardFlag);
      continue;
    }
    if (strncmp(s, "RewardVal=", 10) == 0) {
      s += 10;
      Events[NStages][NEvents].RewardVal = atof(s);
      report("  Reward Value: %f\n", Events[NStages][NEvents].RewardVal);
      continue;
    }

  }  // end while

  // sort events!... (for now I rely on the fact that events are sorted)
  // update: code now relies on fact that events are NOT sorted here

  return 1;
}


// ======================================================================================
// GenerateNetwork()
//
// Generates all the structures which are needed to run the simulation
// on the basis of PopD structures. It also allocates the memory for the
// network. PopD is initialized in DescribeNetwork.
// ======================================================================================

int GenerateNetwork() {
  int p, i, j, r, tp, tpi, tn, k, rd, na;
  int ni[MAXTN], tpni[MAXTN], trni[MAXTN];
  float eff[MAXTN], ts[MAXTN], timets[MAXTN];
  float efficacy;

  if (flagverbose) {
    report("\nGenerating network...\n");
  }

  // loop over all the populations
  for (p = 0; p < Npop; p++) {
    strcpy(Pop[p].Label, PopD[p].Label);
    if (flagverbose) {
      report("Population %2d: %s\n", p, Pop[p].Label);
    }

    for (rd = 0; rd < PopD[p].Nreceptors; rd++) {
      // external input: compute first the asymptoic mu and sigma (m,s in nphys
      // notation) of the conductances
      //          do{efficacy=(gasdev()*PopD[p].ExtEffSD[rd])+PopD[p].MeanExtEff[rd];}while(efficacy<0);
      efficacy = PopD[p].MeanExtEff[rd];
      PopD[p].MeanExtMuS[rd] = PopD[p].FreqExt[rd] * .001 * efficacy *
                               PopD[p].MeanExtCon[rd] * PopD[p].Tau[rd];
      PopD[p].MeanExtSigmaS[rd] =
          sqrt(PopD[p].Tau[rd] * .5 * PopD[p].FreqExt[rd] * .001 * efficacy *
               efficacy * PopD[p].MeanExtCon[rd]);
      PopD[p].FreqExtDecay[rd] = 0.999;
      //? PopD[p].FreqExtNorm[rd] =
      //?     PopD[p].FreqExtDecay[rd] / (1 - PopD[p].FreqExtDecay[rd]);
      //? PopD[p].FreqExtMem[rd] = PopD[p].MeanExtEff[rd] * PopD[p].FreqExtNorm[rd];
      report("Pop %d Conductance: %d m=%f nS s=%f nS\n", p, rd,
             PopD[p].MeanExtMuS[rd], PopD[p].MeanExtSigmaS[rd]);
    }

    // allocate memory for all neurons
    Pop[p].Ncells = PopD[p].Ncells;
    if (flagverbose) {
      report("  - Number of cells: %d\n", Pop[p].Ncells);
    }
    Pop[p].Cell = (Neuron *)calloc(Pop[p].Ncells, sizeof(Neuron));

    // init auxiliary variables like the tables of spikes
    if (delayindt > MAXDELAYINDT) {
      printf("ERROR: delay too long. Increase MAXDELAYINDT and recompile\n");
      return -1;
    }
    Pop[p].CTableofSpikes = delayindt;
    Pop[p].DTableofSpikes = 0;
    for (k = 0; k < MAXDELAYINDT; k++) {
      Pop[p].NTableofSpikes[k] = 0;
    }

    // generate neurons and their axonal trees
    for (i = 0; i < Pop[p].Ncells; i++) {
      // single neuron parameters
      Pop[p].Cell[i].Taum = PopD[p].Taum;
      Pop[p].Cell[i].ResetPot = PopD[p].ResetPot;
      Pop[p].Cell[i].C = PopD[p].C;
      Pop[p].Cell[i].RestPot = PopD[p].RestPot;
      Pop[p].Cell[i].Threshold = PopD[p].Threshold;
      Pop[p].Cell[i].Vk = PopD[p].Vk;
      Pop[p].Cell[i].alpha_ca = PopD[p].alpha_ca;
      Pop[p].Cell[i].tau_ca = PopD[p].tau_ca;
      Pop[p].Cell[i].g_ahp = PopD[p].g_ahp;
      Pop[p].Cell[i].g_adr_max = PopD[p].g_adr_max;
      Pop[p].Cell[i].Vadr_h = PopD[p].Vadr_h;
      Pop[p].Cell[i].Vadr_s = PopD[p].Vadr_s;
      Pop[p].Cell[i].ADRRevPot = PopD[p].ADRRevPot;
      Pop[p].Cell[i].g_k_max = PopD[p].g_k_max;
      Pop[p].Cell[i].Vk_h = PopD[p].Vk_h;
      Pop[p].Cell[i].Vk_s = PopD[p].Vk_s;
      Pop[p].Cell[i].tau_k_max = PopD[p].tau_k_max;
      Pop[p].Cell[i].n_k = 0;

      Pop[p].Cell[i].tauhm = PopD[p].tauhm;
      Pop[p].Cell[i].tauhp = PopD[p].tauhp;
      Pop[p].Cell[i].V_h = PopD[p].V_h;
      Pop[p].Cell[i].V_T = PopD[p].V_T;
      Pop[p].Cell[i].g_T = PopD[p].g_T;
      Pop[p].Cell[i].h = 1.0;

      // single neuron parameters -- dopaminergic learning
      Pop[p].Cell[i].dpmn_type = PopD[p].dpmn_type;
      Pop[p].Cell[i].dpmn_cortex = PopD[p].dpmn_cortex;
      Pop[p].Cell[i].dpmn_alphaw = PopD[p].dpmn_alphaw;
      Pop[p].Cell[i].dpmn_dPRE = PopD[p].dpmn_dPRE;
      Pop[p].Cell[i].dpmn_dPOST = PopD[p].dpmn_dPOST;
      Pop[p].Cell[i].dpmn_tauE = PopD[p].dpmn_tauE;
      Pop[p].Cell[i].dpmn_tauPRE = PopD[p].dpmn_tauPRE;
      Pop[p].Cell[i].dpmn_tauPOST = PopD[p].dpmn_tauPOST;
      Pop[p].Cell[i].dpmn_c = PopD[p].dpmn_c;
      Pop[p].Cell[i].dpmn_wmax = PopD[p].dpmn_wmax;
      Pop[p].Cell[i].dpmn_taug = PopD[p].dpmn_taug;
      Pop[p].Cell[i].dpmn_Q1 = PopD[p].dpmn_Q1;
      Pop[p].Cell[i].dpmn_alpha = PopD[p].dpmn_alpha;
      Pop[p].Cell[i].dpmn_APRE = PopD[p].dpmn_APRE;
      Pop[p].Cell[i].dpmn_APOST = PopD[p].dpmn_APOST;
      Pop[p].Cell[i].dpmn_E = PopD[p].dpmn_E;
      Pop[p].Cell[i].dpmn_w = PopD[p].dpmn_w;
      Pop[p].Cell[i].dpmn_XPRE = PopD[p].dpmn_XPRE;
      Pop[p].Cell[i].dpmn_XPOST = PopD[p].dpmn_XPOST;
      Pop[p].Cell[i].dpmn_DAp = PopD[p].dpmn_DAp;
      Pop[p].Cell[i].dpmn_tauDOP = PopD[p].dpmn_tauDOP;
      Pop[p].Cell[i].dpmn_DAt = PopD[p].dpmn_DAt;
      Pop[p].Cell[i].dpmn_a = PopD[p].dpmn_a;
      Pop[p].Cell[i].dpmn_b = PopD[p].dpmn_b;
      Pop[p].Cell[i].dpmn_m = PopD[p].dpmn_m;
      Pop[p].Cell[i].dpmn_taum = PopD[p].dpmn_taum;
      Pop[p].Cell[i].dpmn_Q2 = PopD[p].dpmn_Q2;

      // receptors
      Pop[p].Cell[i].Nreceptors = PopD[p].Nreceptors;
      for (r = 0; r < Pop[p].Cell[i].Nreceptors; r++) {
        // parameters (simply copy if the network is homoegeneous)
        Pop[p].Cell[i].Tau[r] = PopD[p].Tau[r];
        Pop[p].Cell[i].RevPots[r] = PopD[p].RevPots[r];
        Pop[p].Cell[i].MgFlag[r] = PopD[p].MgFlag[r];  // magnesium block
        // init
        Pop[p].Cell[i].LS[r] = 0.;

        // external input
        do {
          efficacy = (gasdev() * PopD[p].ExtEffSD[r]) + PopD[p].MeanExtEff[r];
        } while (efficacy < 0);
        Pop[p].Cell[i].ExtMuS[r] = PopD[p].FreqExt[r] * .001 * efficacy *
                                   PopD[p].MeanExtCon[r] * PopD[p].Tau[r];
        Pop[p].Cell[i].ExtSigmaS[r] =
            sqrt(PopD[p].Tau[r] * .5 * PopD[p].FreqExt[r] * .001 * efficacy *
                 efficacy * PopD[p].MeanExtCon[r]);
        // if(r==0)printf("%f\n",Pop[p].Cell[i].ExtMuS[r]);
        Pop[p].Cell[i].ExtS[r] = 0.;

      }  // end for r

      // init
      Pop[p].Cell[i].V = Pop[p].Cell[i].RestPot;
      Pop[p].Cell[i].RefrState = 0;
      Pop[p].Cell[i].TimeLastSpike =
          -10000.;  // time of the last emitted spike (for NMDA saturation)
      Pop[p].Cell[i].PTimeLastSpike = -10000.;  // time of spike emitted
                                                // previous the last emitted
                                                // spiek (for NMDA saturation)

      // Axonal tree -------------------------------
      // loop on target populations
      Pop[p].Cell[i].Naxonals = 0;

      for (tpi = 0; tpi < PopD[p].NTargetPops; tpi++) {
        tp = PopD[p]
                 .TargetPops[tpi];  // target population (tpi=target pop index)
        // loop on the neurons of the target population

        // choose the target neurons/populations and put them in a temporary
        // vector ni/tpni
        na = Pop[p].Cell[i].Naxonals;  // auxiliary variable to speed up

        for (tn = 0; tn < PopD[tp].Ncells; tn++) {
          if (tp == p) {
            if (i == tn) continue;  // avoid self connections
          }

          if (drand49() <
              PopD[p].SynP[tpi].Connectivity) {  // the connection exists
            ni[na] = tn;                         // target neuron
            tpni[na] = tp;                       // target population
            trni[na] = PopD[p].SynP[tpi].TargetReceptor;  // target receptor
            do {
              efficacy = gasdev() * PopD[p].SynP[tpi].EfficacySD +
                         PopD[p].SynP[tpi].MeanEfficacy;
            } while (efficacy < 0);
            eff[na] = efficacy;  // efficacy
                                 // printf("%f\n",efficacy);

            if (strncmp(PopD[tp].ReceptorLabel[trni[na]], "NMDA", 4) == 0) {
              ts[na] = 0.;  // initial LastConductance (for NMDA saturation)
            } else
              ts[na] = -1.;  // not an NMDA type (so, no saturation)
            na++;
            Pop[p].Cell[i].Naxonals++;
          }
        }  // end for tn
      }    // enf for tpi
      //
      Pop[p].Cell[i].Axonals =
          (Synapse *)calloc(Pop[p].Cell[i].Naxonals, sizeof(Synapse));

      for (j = 0; j < Pop[p].Cell[i].Naxonals; j++) {
        Pop[p].Cell[i].Axonals[j].TargetPop = tpni[j];
        Pop[p].Cell[i].Axonals[j].TargetNeuron = ni[j];
        Pop[p].Cell[i].Axonals[j].Efficacy = eff[j];
        Pop[p].Cell[i].Axonals[j].TargetReceptor = trni[j];
        Pop[p].Cell[i].Axonals[j].LastConductance = ts[j];
      }
    }  // end for i
  }    // end for p

  if (flagverbose) {
    report("Network generated\n");
    fflush(stdout);
  }
}


// same as generate network, but it does not allocate memory. Used in the multitrial mode
// (to change the network from trial to trial, the only way is to start again with a different seed)
// This function is not used anymore in the current version.

int InitializeNetwork() {
  int p, i, j, r, tp, tpi, tn, k, rd, na;
  int ni[MAXTN], tpni[MAXTN], trni[MAXTN];
  float eff[MAXTN], ts[MAXTN], timets[MAXTN];

  if (flagverbose) {
    report("\nGenerating network...\n");
  }

  // loop over all the populations
  for (p = 0; p < Npop; p++) {
    strcpy(Pop[p].Label, PopD[p].Label);
    if (flagverbose) {
      report("Population %2d: %s\n", p, Pop[p].Label);
    }

    for (rd = 0; rd < PopD[p].Nreceptors; rd++) {
      // external input: compute first the asymptoic mu and sigma (m,s in nphys
      // notation) of the conductances
      // CAREFUL: PROTOCOL FILE SHOULD BE REREAD TO INITIALIZE CORRECTLY EXT
      // FREQS (THEY MIGHT HAVE BEEN CHANGED IN THE PREVIOUS TRIAL

      PopD[p].MeanExtMuS[rd] = PopD[p].FreqExt[rd] * .001 *
                               PopD[p].MeanExtEff[rd] * PopD[p].MeanExtCon[rd] *
                               PopD[p].Tau[rd];
      PopD[p].MeanExtSigmaS[rd] =
          sqrt(PopD[p].Tau[rd] * .5 * PopD[p].FreqExt[rd] * .001 *
               PopD[p].MeanExtEff[rd] * PopD[p].MeanExtEff[rd] *
               PopD[p].MeanExtCon[rd]);
      report("Pop %d Conductance: %d m=%f nS s=%f nS\n", p, rd,
             PopD[p].MeanExtMuS[rd], PopD[p].MeanExtSigmaS[rd]);
    }

    // init auxiliary variables like the tables of spikes
    if (delayindt > MAXDELAYINDT) {
      printf("ERROR: delay too long. Increase MAXDELAYINDT and recompile\n");
      return -1;
    }
    Pop[p].CTableofSpikes = delayindt;
    Pop[p].DTableofSpikes = 0;
    for (k = 0; k < MAXDELAYINDT; k++) {
      Pop[p].NTableofSpikes[k] = 0;
    }

    // init     neurons and their axonal trees
    for (i = 0; i < Pop[p].Ncells; i++) {
      for (r = 0; r < Pop[p].Cell[i].Nreceptors; r++) {
        Pop[p].Cell[i].LS[r] = 0.;

        // external input
        Pop[p].Cell[i].ExtMuS[r] = PopD[p].MeanExtMuS[r];
        Pop[p].Cell[i].ExtSigmaS[r] = PopD[p].MeanExtSigmaS[r];
        Pop[p].Cell[i].ExtS[r] = 0.;
      }  // end for r

      // init
      Pop[p].Cell[i].V = Pop[p].Cell[i].RestPot;
      Pop[p].Cell[i].Ca = 0;
      Pop[p].Cell[i].RefrState = 0;
      Pop[p].Cell[i].TimeLastSpike =
          -10000.;  // time of the last emitted spike (for NMDA saturation)
      Pop[p].Cell[i].PTimeLastSpike = -10000.;  // time of spike emitted
                                                // previous the last emitted
                                                // spiek (for NMDA saturation)

    }  // end for i
  }    // end for p

  if (flagverbose) {
    report("Network initialized\n");
    fflush(stdout);
  }
}



// ---------------------------------------------------------------------------------------------------

/*

Trick for NMDA:

$$ {ds_k \over dt} = -{s_k \over \tau} +\alpha(1-s_k)\sum_j \delta(t-t^k_j)$$

Multiply by $w_k$ and sum:

$$ {dS \over dt} = -S \over \tau+\sum_k \alpha (1-s_k)w_k \delta(t-t^k_j)$$

*/

// float current_freq;

int SimulateOneTimeStep() {
  int aux;
  int p, i, j, r, sourceneuron;
  int tn, tp, tr;
  float s, saturationfactor;
  float Vaux;  // auxiliary V: during the emission of the spike V is set
               // artificially to 0. This is bad for the reversal potential
  float g_rb;  // rebound burst
  float g_adr, g_k, tau_max, alpha, beta, dv, n, tau_n, n_inif, efficacy,
      ExtMuS, ExtSigmaS;
  static float freq[MAXP][MAXRECEPTORS];
  static float last_freq[MAXP][MAXRECEPTORS];
  static int flag = 0;
  static

      // DEBUG
      float nvalues = 0,
            value = 0;

  // END DEBUG

  if (flag == 0) {
    for (j = 0; j < MAXP; j++) {
      for (i = 0; i < MAXRECEPTORS; i++) freq[j][i] = PopD[j].FreqExt[i];
      last_freq[j][i] = PopD[j].FreqExt[i];
    }
    flag = 1;
  }

  // dopaminergic learning, reset Xpre/Xpost for this tick
  for (p = 0; p < Npop; p++) {
    if (PopD[p].dpmn_type) {
      for (i = 0; i < Pop[p].Ncells; i++) {
        Pop[p].Cell[i].dpmn_XPRE = 0;
        Pop[p].Cell[i].dpmn_XPOST = 0;
      }
    }
  }

  // Compute the decay of the total conductances and add external input
  // ------------------------------------------------------------------
  for (p = 0; p < Npop; p++) {
    for (r = 0; r < MAXRECEPTORS; r++) {
      if (PopD[p].FreqExtSD[r] != 0) {
        // do{freq[p][r]=PopD[p].FreqExt[r]+gasdev()*PopD[p].FreqExtSD[r];}while(freq[p][r]<0);
        do {
          freq[p][r] += -(1 - PopD[p].FreqExtDecay[r]) *
                            (last_freq[p][r] - PopD[p].FreqExt[r]) +
                        gasdev() * PopD[p].FreqExtSD[r];
        } while (freq[p][r] < 0);
        last_freq[p][r] = freq[p][r];
        //? ext_freq = freq[1][0];

      } else {
        freq[p][r] = PopD[p].FreqExt[r];
        //? ext_freq = freq[1][0];
      }
    }
    //      current_freq=freq[0][0];
    for (i = 0; i < Pop[p].Ncells; i++) {
      for (r = 0; r < Pop[p].Cell[i].Nreceptors; r++) {
        //? EQUATION 5/6 for external inputs
        efficacy = PopD[p].MeanExtEff[r];
        Pop[p].Cell[i].ExtMuS[r] = freq[p][r] * .001 * efficacy *
                                   PopD[p].MeanExtCon[r] *
                                   Pop[p].Cell[i].Tau[r];
        Pop[p].Cell[i].ExtSigmaS[r] =
            sqrt(Pop[p].Cell[i].Tau[r] * .5 * freq[p][r] * .001 * efficacy *
                 efficacy * PopD[p].MeanExtCon[r]);
        s = Pop[p].Cell[i].ExtSigmaS[r];
        if (s != 0.)  // to optimize
        {
          Pop[p].Cell[i].ExtS[r] +=
              dt / Pop[p].Cell[i].Tau[r] *
                  (-Pop[p].Cell[i].ExtS[r] + Pop[p].Cell[i].ExtMuS[r]) +
              s * sqrt(dt * 2. / Pop[p].Cell[i].Tau[r]) * gasdev();
        } else {
          Pop[p].Cell[i].ExtS[r] +=
              dt / Pop[p].Cell[i].Tau[r] *
              (-Pop[p].Cell[i].ExtS[r] + Pop[p].Cell[i].ExtMuS[r]);
        }

        //? EQUATION 5/6 TERM 2 for internal inputs
        Pop[p].Cell[i].LS[r] *= exp(-dt / Pop[p].Cell[i].Tau[r]);  // decay
      }
    }
  }

  // Update the total conductances (changes provoked by the spikes)
  // --------------------------------------------------------------
    // CATI: STD,STF equations removed!
  for (p = 0; p < Npop; p++) {  // if (Time==0) printf("the spike tabel %d\n",
                                // Pop[p].TableofSpikes[20][100]);
    // loop over all the spikes emitted at time t-delay (they are received now)
    for (i = 0; i < Pop[p].NTableofSpikes[Pop[p].DTableofSpikes]; i++) {
      sourceneuron = Pop[p].TableofSpikes[Pop[p].DTableofSpikes][i];

      // for each spike, loop over the target conductances
      for (j = 0; j < Pop[p].Cell[sourceneuron].Naxonals; j++) {
        tn = Pop[p].Cell[sourceneuron].Axonals[j].TargetNeuron;
        tp = Pop[p].Cell[sourceneuron].Axonals[j].TargetPop;
        tr = Pop[p].Cell[sourceneuron].Axonals[j].TargetReceptor;

        float pathway_strength;

        if (Pop[p].Cell[sourceneuron].dpmn_cortex && Pop[tp].Cell[tn].dpmn_type && tr == AMPA) {
          pathway_strength = Pop[tp].Cell[tn].dpmn_w;
        } else {
          pathway_strength = Pop[p].Cell[sourceneuron].Axonals[j].Efficacy;
        }

        if (Pop[p].Cell[sourceneuron].Axonals[j].LastConductance <  0.) {  // NO NMDA (no saturation)
          Pop[tp].Cell[tn].LS[tr] += pathway_strength;  // no saturation
        } else {
          // Now it should be correct. ALPHA factor to be determined (jump for every
          // spike): now it is the maximum of a single spike
          // TEMPORARY
#define ALPHA 0.6332
          // 0.6332 is the best value for the area at 55 Hz. Best value depends
          // on the frequency!!!
          Pop[p].Cell[sourceneuron].Axonals[j].LastConductance *=
              exp(-(Time - Pop[p].Cell[sourceneuron].PTimeLastSpike) /
                  Pop[tp].Cell[tn].Tau[tr]);

          Pop[tp].Cell[tn].LS[tr] += pathway_strength *
              ALPHA * (1. - Pop[p].Cell[sourceneuron].Axonals[j].LastConductance);

          Pop[p].Cell[sourceneuron].Axonals[j].LastConductance +=
              ALPHA * (1. - Pop[p].Cell[sourceneuron].Axonals[j].LastConductance);
        }

        // dopaminergic learning
        if (Pop[p].Cell[sourceneuron].dpmn_cortex && Pop[tp].Cell[tn].dpmn_type) {
          Pop[tp].Cell[tn].dpmn_XPRE = 1; // presynaptic from perspective of target neuron
        }
      }
    }
  }

  // Update the neuronal variables
  // -----------------------------

  for (p = 0; p < Npop; p++) {
    Pop[p].NTableofSpikes[Pop[p].CTableofSpikes] =
        0;  // reset the number of emitted spikes for pop p
    for (i = 0; i < Pop[p].Ncells; i++) {
      if (Pop[p].Cell[i].V < Pop[p].Cell[i].V_h) {
        // EQUATION 3
        Pop[p].Cell[i].h +=
            (1.0 - Pop[p].Cell[i].h) * dt / Pop[p].Cell[i].tauhp;
        // EQUATION 1 TERM 2
        g_rb = 0;
      } else {
        // EQUATION 2
        Pop[p].Cell[i].h += -Pop[p].Cell[i].h * dt / Pop[p].Cell[i].tauhm;
        // EQUATION 1 TERM 2
        g_rb = Pop[p].Cell[i].g_T * Pop[p].Cell[i].h;
      }

      if (Pop[p].Cell[i].V > Pop[p].Cell[i].Threshold) {
        Pop[p].Cell[i].V =
            Pop[p].Cell[i].ResetPot;  // special state after emission
        Pop[p].Cell[i].RefrState--;
        continue;
      }

      // skip this cell if in refractory period

      if (Pop[p].Cell[i].RefrState) {
        Pop[p].Cell[i].RefrState--;
        continue;
      }

      // Anomalous delayed rectiflier (ADR)
      if (Pop[p].Cell[i].g_adr_max == 0)  // No ADR
        g_adr = 0;
      else  // with ADR
        g_adr = Pop[p].Cell[i].g_adr_max /
                (1 + exp((Pop[p].Cell[i].V - Pop[p].Cell[i].Vadr_h) /
                         Pop[p].Cell[i].Vadr_s));

      // potassium outward rectifying current
      if (Pop[p].Cell[i].g_k_max == 0)  // No outward current
        g_k = 0;
      else {  // with outward current
              //  g_k =
              //  Pop[p].Cell[i].g_k_max/(1+exp((-Pop[p].Cell[i].V+Pop[p].Cell[i].Vk_h)/Pop[p].Cell[i].Vk_s));
        tau_max = Pop[p].Cell[i].tau_k_max;
        dv = (Pop[p].Cell[i].V + 55.0);
        //  alpha=(-10.0/tau_max)*(dv-49)/(1-exp(-(dv-49)/100));
        //            beta=(0.17/tau_max)*exp(-(dv-11)/10);
        tau_n = tau_max / (exp(-1 * dv / 30) + exp(dv / 30));
        n_inif = 1 / (1 + exp(-(Pop[p].Cell[i].V - Pop[p].Cell[i].Vk_h) /
                              Pop[p].Cell[i].Vk_s));

        Pop[p].Cell[i].n_k += -dt / tau_n * (Pop[p].Cell[i].n_k - n_inif);
        g_k = Pop[p].Cell[i].g_k_max * Pop[p].Cell[i].n_k;
        //	    printf("v=%f dv=%f alpha=%f beta=%f g_k=%f
        //\n",Pop[p].Cell[i].V,dv,alpha,beta,g_k);
      }

      // decay
      if (Pop[p].Cell[i].g_ahp == 0)  // No spike-frequency adaptation
        // EQUATION 1
        Pop[p].Cell[i].V +=
            -dt *
            (1 / Pop[p].Cell[i].Taum *
                 (Pop[p].Cell[i].V - Pop[p].Cell[i].RestPot) +
             g_adr / Pop[p].Cell[i].C *
                 (Pop[p].Cell[i].V - Pop[p].Cell[i].ADRRevPot) +
             g_k / Pop[p].Cell[i].C *
                 (Pop[p].Cell[i].V - Pop[p].Cell[i].ADRRevPot) +
             g_rb / Pop[p].Cell[i].C * (Pop[p].Cell[i].V - Pop[p].Cell[i].V_T));
      else  // with spike-frequency adaptation (the factor 1/1000 is needed to
            // convert nS/nF to 1/ms)
        // EQUATION 1
        Pop[p].Cell[i].V +=
            -dt *
            (1 / Pop[p].Cell[i].Taum *
                 (Pop[p].Cell[i].V - Pop[p].Cell[i].RestPot) +
             Pop[p].Cell[i].Ca * Pop[p].Cell[i].g_ahp / Pop[p].Cell[i].C *
                 0.001 * (Pop[p].Cell[i].V - Pop[p].Cell[i].Vk) +
             g_adr / Pop[p].Cell[i].C *
                 (Pop[p].Cell[i].V - Pop[p].Cell[i].ADRRevPot) +
             g_k / Pop[p].Cell[i].C *
                 (Pop[p].Cell[i].V - Pop[p].Cell[i].ADRRevPot) +
             g_rb / Pop[p].Cell[i].C * (Pop[p].Cell[i].V - Pop[p].Cell[i].V_T));

      // [Ca] decay -- 1st order approximation
      Pop[p].Cell[i].Ca += -Pop[p].Cell[i].Ca * dt / Pop[p].Cell[i].tau_ca;

      Vaux = Pop[p].Cell[i].V;
      if (Vaux > Pop[p].Cell[i].Threshold) Vaux = Pop[p].Cell[i].Threshold;

      // now add the synaptic currents (the factor 1/1000 is needed to convert
      // nS/nF to 1/ms)
      // EQUATION 1 TERM 3, EQUATION 4
      for (r = 0; r < Pop[p].Cell[i].Nreceptors; r++) {
        if (Pop[p].Cell[i].MgFlag[r]) {  // magnesium block
          Pop[p].Cell[i].V += dt * (Pop[p].Cell[i].RevPots[r] - Vaux) * .001 *
                              (Pop[p].Cell[i].LS[r] + Pop[p].Cell[i].ExtS[r]) /
                              Pop[p].Cell[i].C /
                              (1. + exp(-0.062 * Vaux) / 3.57);

          /*		// DEBUG DEBUG DEBUG
          if(p==1 && i==0) {
            printf("[%f]",Pop[p].Cell[i].LS[r]);
          }
          // end DEBUG */

        } else {
          Pop[p].Cell[i].V += dt * (Pop[p].Cell[i].RevPots[r] - Vaux) * .001 *
                              (Pop[p].Cell[i].LS[r] + Pop[p].Cell[i].ExtS[r]) /
                              Pop[p].Cell[i].C;
        }
      }
      // spike condition
      if (Pop[p].Cell[i].V > Pop[p].Cell[i].Threshold) {
        // a spike is emitted
        Pop[p].TableofSpikes[Pop[p].CTableofSpikes]
                            [Pop[p].NTableofSpikes[Pop[p].CTableofSpikes]] = i;
        if (Pop[p].NTableofSpikes[Pop[p].CTableofSpikes] < MAXSPIKESINDT - 1)
          Pop[p].NTableofSpikes[Pop[p].CTableofSpikes]++;
        else {
          printf(
              "\nERROR: too many spikes in a dt (change MAXSPIKESINDT and "
              "recompile)\n");
          fflush(stdout);
        }

        Pop[p].Cell[i].V = Pop[p].Cell[i].ResetPot;
        Pop[p].Cell[i].PTimeLastSpike = Pop[p].Cell[i].TimeLastSpike;
        Pop[p].Cell[i].TimeLastSpike = Time;

        Pop[p].Cell[i].V = 0.;  // spike! (temporary)
        Pop[p].Cell[i].RefrState =
            (int)floor(2. / dt);  // refractory period!!! (temporary)

        // [Ca] increases;
        Pop[p].Cell[i].Ca += Pop[p].Cell[i].alpha_ca;

        // dopaminergic learning
        if (PopD[p].dpmn_type){
          Pop[p].Cell[i].dpmn_XPOST = 1; // this is the post-synaptic cell spiking
        }
      }
    }
  }

  // dopaminergic learning
  for (p = 0; p < Npop; p++) {
    if (PopD[p].dpmn_type) {
      for (i = 0; i < Pop[p].Ncells; i++) {
        float fDA;
        float DA;
        float DAinc;
        if (Pop[p].Cell[i].dpmn_type) {
          // these are simply the 1st order approximations, RK45 not used
          // equation 5 term 2
          Pop[p].Cell[i].dpmn_DAp -= dt * Pop[p].Cell[i].dpmn_DAp / Pop[p].Cell[i].dpmn_tauDOP;
          // equation 5 term 1, the learning step
          if (rewardflag && Time >= dpmn_RewardTime) {
            // report("dpmn type %d\n", Pop[p].Cell[i].dpmn_type);
            if (rewardflag == 1) {
              DAinc = EndingEvent.RewardVal - Pop[p].Cell[i].dpmn_Q1;
              Pop[p].Cell[i].dpmn_Q1 += Pop[p].Cell[i].dpmn_alpha * (DAinc);
            }
            if (rewardflag == 2) {
              DAinc = EndingEvent.RewardVal - Pop[p].Cell[i].dpmn_Q2;
              Pop[p].Cell[i].dpmn_Q2 += Pop[p].Cell[i].dpmn_alpha * (DAinc);
            }
            Pop[p].Cell[i].dpmn_DAp = DAinc;
          }
          // equations 2
          Pop[p].Cell[i].dpmn_APRE += dt * (Pop[p].Cell[i].dpmn_dPRE * Pop[p].Cell[i].dpmn_XPRE - Pop[p].Cell[i].dpmn_APRE)
                           / Pop[p].Cell[i].dpmn_tauPRE;
          Pop[p].Cell[i].dpmn_APOST += dt * (Pop[p].Cell[i].dpmn_dPOST * Pop[p].Cell[i].dpmn_XPOST - Pop[p].Cell[i].dpmn_APOST)
                            / Pop[p].Cell[i].dpmn_tauPOST;
        //  if (Pop[p].Cell[i].dpmn_APOST == Pop[p].Cell[i].dpmn_APOST) {
        //    report("test\n");
          //}
          // equation 3
          Pop[p].Cell[i].dpmn_E += dt * (Pop[p].Cell[i].dpmn_XPOST * Pop[p].Cell[i].dpmn_APRE
                              - Pop[p].Cell[i].dpmn_XPRE * Pop[p].Cell[i].dpmn_APOST - Pop[p].Cell[i].dpmn_E)
                        / Pop[p].Cell[i].dpmn_tauE;
          // calculate DA (total dopamine)
          DA = Pop[p].Cell[i].dpmn_m * (Pop[p].Cell[i].dpmn_DAp + Pop[p].Cell[i].dpmn_DAt);
          // if (DA < 0) {
          //   DA = 0;
          // }
          if (Pop[p].Cell[i].dpmn_taum > 1) { // so that 0 = no decay as opposed to infinite decay
            Pop[p].Cell[i].dpmn_m -= dt * Pop[p].Cell[i].dpmn_m / Pop[p].Cell[i].dpmn_taum;
          }
          // equation 4
          /* fDA = Pop[p].Cell[i].dpmn_a * pow(DA - Pop[p].Cell[i].dpmn_c, 3)
                / (Pop[p].Cell[i].dpmn_b + pow(abs(DA - Pop[p].Cell[i].dpmn_c), 3)); */
          if (PopD[p].dpmn_type == 1) {
            fDA = DA;
            } else {
            fDA = DA/(2.5+abs(DA));
          }
          Pop[p].Cell[i].dpmn_w += dt * (Pop[p].Cell[i].dpmn_wmax - Pop[p].Cell[i].dpmn_w)
                                * Pop[p].Cell[i].dpmn_alphaw * fDA * Pop[p].Cell[i].dpmn_E;
        }
      }
    }
  }

  // reward has been performed if needed, so reset rewardflag
  if (Time >= dpmn_RewardTime) {
    rewardflag = 0;
  }

  // Update the pointers of the table of spikes
  // ---------------------------------------------------------------

  for (p = 0; p < Npop; p++) {
    Pop[p].CTableofSpikes++;
    if (Pop[p].CTableofSpikes > MAXDELAYINDT - 1) {
      Pop[p].CTableofSpikes = 0;
    }
    Pop[p].DTableofSpikes++;
    if (Pop[p].DTableofSpikes > MAXDELAYINDT - 1) {
      Pop[p].DTableofSpikes = 0;
    }
  }
}

// DATA ANALYSIS
// --------------------------------------------------------------------------------------------

// A matlab script is generated at the beginning, just before starting the simulation.

#define TIMEWINDOWFORFREQ 10.  // time window on which the mean pop frequency is estimated (in ms)
#define RASTERPLOTNEURONS 50   // number of neurons in the raster plot
#define NUMBEROFTRACES 2  // number of visualized traces of V
#define STEPSFORPRINTIGFREQS 500 // every ... step, the frequencies are printed
#define STEPSFORSAVINGFREQS 5 // every ... step the frequencies are saved (not always, to save space)
#define STEPSFORFLUSHING 80
#define SPIKEBUFFER 300 //szie of the array SpikeBuffer[] in SaveSpikes(). This value should be no
                        // smaller than TIMEWINDOWFORFREQ/dt

int NumberofTraces=0;



int SaveSpikes(int eventflag) {
  static int InitFlag = 1;
  static FILE *devspikes[MAXP], *devfreqs;
  static float meanfreqs[MAXP];
  static float timelastevent;
  static float meanfreqsbetweenevents[MAXP];
  static float SpikeBuffer[MAXP][SPIKEBUFFER];
  static int counter;
  static int lasttrial = 0;
  static int currentpt, buffersize;  // for SpikeBuffer[][]
  int i, p, TempPointer;
  float TempBuffer;
  char TempName[100];

  // initialize if it is the first call
  if (InitFlag || (lasttrial != CurrentTrial)) {
    // if there is a new trial, close all the files of the previous trial
    if (lasttrial != CurrentTrial) {
      if (FlagSaveAllSpikes) {
        for (p = 0; p < Npop; p++) {
          fclose(devspikes[p]);
        }
      }
      lasttrial = CurrentTrial;
      // and then open th new ones
    }

    buffersize = (int)(TIMEWINDOWFORFREQ / dt + 0.5);
    if (buffersize >= SPIKEBUFFER) {
      printf(
          "Error: SPIKEBUFFER is too small. Edit the code and recomplie the "
          "program. \n");
      exit(1);
    };
    currentpt = 0;

    printf("\n buffersize: %d", buffersize);

    // open all files
    printf("\n Time (ms) ");

    for (p = 0; p < Npop; p++) {
      sprintf(TempName, "pop%d_%d.dat", p + 1, Trialnumber);
      if (FlagSaveAllSpikes) {
        devspikes[p] = fopen(TempName, "w");
        if (devspikes[p] == NULL) return 0;
      }
      meanfreqs[p] = 0.;
      meanfreqsbetweenevents[p] = 0.;

      for (i = 0; i < SPIKEBUFFER; i++) SpikeBuffer[p][i] = 0;

      printf("%12s", Pop[p].Label);
    }
    timelastevent = 0.;

    sprintf(TempName, "popfreqs%d.dat", Trialnumber);
    devfreqs = fopen(TempName, "w");
    if (devfreqs == NULL) return 0;

    fprintf(devfreqs, "Time (ms)\t");
    for (p = 0; p < Npop; p++) {
      fprintf(devfreqs, "%s\t", Pop[p].Label);
    }
    fprintf(devfreqs, "\n");
    fflush(devfreqs);

    InitFlag = 0;
    counter = 0;
    printf(
        "\n---------------------------------------------------------------\n");
  }

  if ((counter % STEPSFORSAVINGFREQS) == 0) fprintf(devfreqs, "%f\t", Time);

  // if((counter % STEPSFORPRINTIGFREQS)==0) printf("%7.1f ms",Time);

  for (p = 0; p < Npop; p++) {
    TempPointer = Pop[p].CTableofSpikes - 1;
    if (TempPointer < 0) TempPointer = MAXDELAYINDT - 1;

    meanfreqsbetweenevents[p] += (float)Pop[p].NTableofSpikes[TempPointer] /
                                 (float)Pop[p].Ncells / dt * 1000.;

    meanfreqs[p] +=
        -SpikeBuffer[p][currentpt] +
        (TempBuffer = (float)Pop[p].NTableofSpikes[TempPointer] /
                      (float)Pop[p].Ncells * 1000.0 / TIMEWINDOWFORFREQ); //  * 1000 / TIMEWINDOWFORFREQ

    SpikeBuffer[p][currentpt] = TempBuffer;

    //      meanfreqs[p]+=dt/TIMEWINDOWFORFREQ*(-meanfreqs[p]+(float)Pop[p].NTableofSpikes[TempPointer]/(float)Pop[p].Ncells/dt*1000.);
    //      // compute mean freq in Hz on a time window of 10 ms

    // if((counter % STEPSFORPRINTIGFREQS)==0) printf("%12.1f",meanfreqs[p]);
    //      if((counter % STEPSFORPRINTIGFREQS)==0) printf("%s FreqExtSD=%f
    //      \n",PopD[0].ReceptorLabel[0],PopD[0].FreqExtSD[0]);
    if ((counter % STEPSFORSAVINGFREQS) == 0) {
      fprintf(devfreqs, "%f\t",
              meanfreqs[p]);  // mean frequency in Hz per neuron
    }

    if (FlagSaveAllSpikes) {
      for (i = 0; i < Pop[p].NTableofSpikes[TempPointer]; i++) {
        fprintf(devspikes[p], "%d\t%f\n", Pop[p].TableofSpikes[TempPointer][i],
                Time);
      }
    }
  }

  // moved from inside the above loop
  if (currentpt < buffersize - 1) {
    currentpt++;
  } else {
    currentpt = 0;
  }

  if ((counter % STEPSFORSAVINGFREQS) == 0) fprintf(devfreqs, "\n");
  // if((counter % STEPSFORPRINTIGFREQS)==0) printf("\n");

  //  if((counter % STEPSFORSAVINGFREQS)==0) fprintf(devfreqs," %f
  //  \n",current_freq);
  //  if((counter % STEPSFORPRINTIGFREQS)==0) printf(" %f \n",current_freq);

  if ((counter % STEPSFORFLUSHING) == 0) {
    if (FlagSaveAllSpikes) {
      for (p = 0; p < Npop; p++) {
        fflush(devspikes[p]);
      }
    }
    fflush(devfreqs);
  }

  if (eventflag) {
    // printf("Average:  ");
    for (p = 0; p < Npop; p++) {
      // printf("%12.1f",meanfreqsbetweenevents[p]/(Time-timelastevent)*dt);
      meanfreqsbetweenevents[p] = 0.;
    }
    // printf("\n");
    // fflush(stdout);
    timelastevent = Time;
  }

  // dynamic cutoff
  int res = 1;
  if ((counter % STEPSFORSAVINGFREQS) == 0) {
    for (int co = 0; co < CCutoff; co++) {
      if (meanfreqs[Cutoffs[CStage][co].PopNumber] > Cutoffs[CStage][co].FreqExt) {
        EndingEvent = Cutoffs[CStage][co];
        res = 0;
      }
    }
  }
  counter++;
  return res;
}

void SaveWeights() {
  static int InitFlag = 1;
  static FILE *devfreqs;
  static int counter;
  static int lasttrial = 0;
  int i, p;
  char TempName[100];

  // initialize if it is the first call
  if (InitFlag || (lasttrial != CurrentTrial)) {
    sprintf(TempName, "popweights%d.dat", Trialnumber);
    devfreqs = fopen(TempName, "w");
    if (devfreqs == NULL) return;
    fprintf(devfreqs, "Time (ms)\t");
    for (p = 0; p < Npop; p++) {
      fprintf(devfreqs, "%s\t", Pop[p].Label);
    }
    fprintf(devfreqs, "\n");
    fflush(devfreqs);
    InitFlag = 0;
    counter = 0;
  }
  if ((counter % STEPSFORSAVINGFREQS) == 0) {
    fprintf(devfreqs, "%f\t", Time);
    for (p = 0; p < Npop; p++) {
      float avg;
      avg = 0;
      for (i = 0; i < Pop[p].Ncells; i++) {
        avg += Pop[p].Cell[i].dpmn_w;
      }
      avg /= Pop[p].Ncells;
      fprintf(devfreqs, "%f\t",
              (avg/1.0) );  // debugging dopamine
    }
    fprintf(devfreqs, "\n");
    fflush(devfreqs);
  }
  counter++;
}

void SaveE() {
  static int InitFlag = 1;
  static FILE *devfreqs;
  static int counter;
  static int lasttrial = 0;
  int i, p;
  char TempName[100];

  // initialize if it is the first call
  if (InitFlag || (lasttrial != CurrentTrial)) {
    sprintf(TempName, "popEs%d.dat", Trialnumber);
    devfreqs = fopen(TempName, "w");
    if (devfreqs == NULL) return;
    fprintf(devfreqs, "Time (ms)\t");
    for (p = 0; p < Npop; p++) {
      fprintf(devfreqs, "%s\t", Pop[p].Label);
    }
    fprintf(devfreqs, "\n");
    fflush(devfreqs);
    InitFlag = 0;
    counter = 0;
  }
  if ((counter % STEPSFORSAVINGFREQS) == 0) {
    fprintf(devfreqs, "%f\t", Time);
    for (p = 0; p < Npop; p++) {
      float avg;
      avg = 0;
      for (i = 0; i < Pop[p].Ncells; i++) {
        avg += Pop[p].Cell[i].dpmn_E;
      }
      avg /= Pop[p].Ncells;
      fprintf(devfreqs, "%f\t", avg );  // debugging dopamine
    }
    fprintf(devfreqs, "\n");
    fflush(devfreqs);
  }
  counter++;
}

void SaveDC() {
  static int InitFlag = 1;
  static FILE *devfreqs;
  static int counter;
  static int lasttrial = 0;
  int i, p;
  char TempName[100];

  // initialize if it is the first call
  if (InitFlag || (lasttrial != CurrentTrial)) {
    sprintf(TempName, "popDCs%d.dat", Trialnumber);
    devfreqs = fopen(TempName, "w");
    if (devfreqs == NULL) return;
    fprintf(devfreqs, "Time (ms)\t");
    for (p = 0; p < Npop; p++) {
      fprintf(devfreqs, "%s\t", Pop[p].Label);
    }
    fprintf(devfreqs, "\n");
    fflush(devfreqs);
    InitFlag = 0;
    counter = 0;
  }
  if ((counter % STEPSFORSAVINGFREQS) == 0) {
    fprintf(devfreqs, "%f\t", Time);
    for (p = 0; p < Npop; p++) {
      float avg;
      avg = 0;
      for (i = 0; i < Pop[p].Ncells; i++) {
        avg += Pop[p].Cell[i].dpmn_cortex;
      }
      avg /= Pop[p].Ncells;
      fprintf(devfreqs, "%f\t", avg );  // debugging dopamine
    }
    fprintf(devfreqs, "\n");
    fflush(devfreqs);
  }
  counter++;
}

void SaveQ1() {
  static int InitFlag = 1;
  static FILE *devfreqs;
  static int counter;
  static int lasttrial = 0;
  int i, p;
  char TempName[100];

  // initialize if it is the first call
  if (InitFlag || (lasttrial != CurrentTrial)) {
    sprintf(TempName, "popQ1s%d.dat", Trialnumber);
    devfreqs = fopen(TempName, "w");
    if (devfreqs == NULL) return;
    fprintf(devfreqs, "Time (ms)\t");
    for (p = 0; p < Npop; p++) {
      fprintf(devfreqs, "%s\t", Pop[p].Label);
    }
    fprintf(devfreqs, "\n");
    fflush(devfreqs);
    InitFlag = 0;
    counter = 0;
  }
  if ((counter % STEPSFORSAVINGFREQS) == 0) {
    fprintf(devfreqs, "%f\t", Time);
    for (p = 0; p < Npop; p++) {
      fprintf(devfreqs, "%f\t",
              (Pop[p].Cell[0].dpmn_Q1 + Pop[p].Cell[1].dpmn_Q1 + Pop[p].Cell[3].dpmn_Q1 + Pop[p].Cell[4].dpmn_Q1)/4 );  // debugging dopamine
    }
    fprintf(devfreqs, "\n");
    fflush(devfreqs);
  }
  counter++;
}

void SaveQ2() {
  static int InitFlag = 1;
  static FILE *devfreqs;
  static int counter;
  static int lasttrial = 0;
  int i, p;
  char TempName[100];

  // initialize if it is the first call
  if (InitFlag || (lasttrial != CurrentTrial)) {
    sprintf(TempName, "popQ2s%d.dat", Trialnumber);
    devfreqs = fopen(TempName, "w");
    if (devfreqs == NULL) return;
    fprintf(devfreqs, "Time (ms)\t");
    for (p = 0; p < Npop; p++) {
      fprintf(devfreqs, "%s\t", Pop[p].Label);
    }
    fprintf(devfreqs, "\n");
    fflush(devfreqs);
    InitFlag = 0;
    counter = 0;
  }
  if ((counter % STEPSFORSAVINGFREQS) == 0) {
    fprintf(devfreqs, "%f\t", Time);
    for (p = 0; p < Npop; p++) {
      fprintf(devfreqs, "%f\t",
              (Pop[p].Cell[0].dpmn_Q2 + Pop[p].Cell[1].dpmn_Q2 + Pop[p].Cell[3].dpmn_Q2 + Pop[p].Cell[4].dpmn_Q2)/4 );  // debugging dopamine
    }
    fprintf(devfreqs, "\n");
    fflush(devfreqs);
  }
  counter++;
}

void SaveDpmn() {
  static int InitFlag = 1;
  static FILE *devfreqs;
  static int counter;
  static int lasttrial = 0;
  int i, p;
  char TempName[100];

  // initialize if it is the first call
  if (InitFlag || (lasttrial != CurrentTrial)) {
    sprintf(TempName, "dopamine%d.dat", Trialnumber);
    devfreqs = fopen(TempName, "w");
    if (devfreqs == NULL) return;
    fprintf(devfreqs, "Time (ms)\t");
    for (p = 0; p < Npop; p++) {
      fprintf(devfreqs, "%s\t", Pop[p].Label);
    }
    fprintf(devfreqs, "\n");
    fflush(devfreqs);
    InitFlag = 0;
    counter = 0;
  }
  if ((counter % STEPSFORSAVINGFREQS) == 0) {
    fprintf(devfreqs, "%f\t", Time);
    for (p = 0; p < Npop; p++) {
      float DA;
      DA = Pop[p].Cell[i].dpmn_m * (Pop[p].Cell[i].dpmn_DAp + Pop[p].Cell[i].dpmn_DAt);
      // if (DA < 0) {
      //   DA = 0;
      // }
      fprintf(devfreqs, "%f\t",
              DA );  // debugging dopamine
    }
    fprintf(devfreqs, "\n");
    fflush(devfreqs);
  }
  counter++;
}

void SaveNMDA() {
  static int InitFlag = 1;
  static FILE *devfreqs;
  static int counter;
  static int lasttrial = 0;
  int i, p;
  char TempName[100];

  // initialize if it is the first call
  if (InitFlag || (lasttrial != CurrentTrial)) {
    sprintf(TempName, "popNMDAs%d.dat", Trialnumber);
    devfreqs = fopen(TempName, "w");
    if (devfreqs == NULL) return;
    fprintf(devfreqs, "Time (ms)\t");
    for (p = 0; p < Npop; p++) {
      fprintf(devfreqs, "%s\t", Pop[p].Label);
    }
    fprintf(devfreqs, "\n");
    fflush(devfreqs);
    InitFlag = 0;
    counter = 0;
  }
  if ((counter % STEPSFORSAVINGFREQS) == 0) {
    fprintf(devfreqs, "%f\t", Time);
    for (p = 0; p < Npop; p++) {
      float avg;
      avg = 0;
      for (i = 0; i < Pop[p].Ncells; i++) {
        avg += Pop[p].Cell[i].LS[NMDA];
      }
      avg /= Pop[p].Ncells;
      fprintf(devfreqs, "%f\t", avg );  // debugging dopamine
    }
    fprintf(devfreqs, "\n");
    fflush(devfreqs);
  }
  counter++;
}

void SaveAMPA() {
  static int InitFlag = 1;
  static FILE *devfreqs;
  static int counter;
  static int lasttrial = 0;
  int i, p;
  char TempName[100];

  // initialize if it is the first call
  if (InitFlag || (lasttrial != CurrentTrial)) {
    sprintf(TempName, "popAMPAs%d.dat", Trialnumber);
    devfreqs = fopen(TempName, "w");
    if (devfreqs == NULL) return;
    fprintf(devfreqs, "Time (ms)\t");
    for (p = 0; p < Npop; p++) {
      fprintf(devfreqs, "%s\t", Pop[p].Label);
    }
    fprintf(devfreqs, "\n");
    fflush(devfreqs);
    InitFlag = 0;
    counter = 0;
  }
  if ((counter % STEPSFORSAVINGFREQS) == 0) {
    fprintf(devfreqs, "%f\t", Time);
    for (p = 0; p < Npop; p++) {
      float avg;
      avg = 0;
      for (i = 0; i < Pop[p].Ncells; i++) {
        avg += Pop[p].Cell[i].LS[AMPA];
      }
      avg /= Pop[p].Ncells;
      fprintf(devfreqs, "%f\t", avg );  // debugging dopamine
    }
    fprintf(devfreqs, "\n");
    fflush(devfreqs);
  }
  counter++;
}

void SaveGABA() {
  static int InitFlag = 1;
  static FILE *devfreqs;
  static int counter;
  static int lasttrial = 0;
  int i, p;
  char TempName[100];

  // initialize if it is the first call
  if (InitFlag || (lasttrial != CurrentTrial)) {
    sprintf(TempName, "popGABAs%d.dat", Trialnumber);
    devfreqs = fopen(TempName, "w");
    if (devfreqs == NULL) return;
    fprintf(devfreqs, "Time (ms)\t");
    for (p = 0; p < Npop; p++) {
      fprintf(devfreqs, "%s\t", Pop[p].Label);
    }
    fprintf(devfreqs, "\n");
    fflush(devfreqs);
    InitFlag = 0;
    counter = 0;
  }
  if ((counter % STEPSFORSAVINGFREQS) == 0) {
    fprintf(devfreqs, "%f\t", Time);
    for (p = 0; p < Npop; p++) {
      float avg;
      avg = 0;
      for (i = 0; i < Pop[p].Ncells; i++) {
        avg += Pop[p].Cell[i].LS[GABA];
      }
      avg /= Pop[p].Ncells;
      fprintf(devfreqs, "%f\t", avg );  // debugging dopamine
    }
    fprintf(devfreqs, "\n");
    fflush(devfreqs);
  }
  counter++;
}

int SaveTraces() {
  int i, p, r;
  static int FlagInit = 1;
  static FILE *devtraces;
  static int lasttrial = 0;
  char TempName[100];
  float Vaux;

  if (NumberofTraces == 0) return 1;

  if (FlagInit || (lasttrial != CurrentTrial)) {
    if (lasttrial != CurrentTrial) {
      fclose(devtraces);
      lasttrial = CurrentTrial;
    }

    sprintf(TempName, "poptraces%d.dat", Trialnumber);
    devtraces = fopen(TempName, "w");
    if (devtraces == NULL) return 0;
    FlagInit = 0;
  }

  fprintf(devtraces, "%f\t", Time);
  for (p = 0; p < Npop; p++) {
    for (i = 0; i < NumberofTraces; i++) {
      Vaux = Pop[p].Cell[i].V;
      if (Vaux > Pop[p].Cell[i].Threshold) Vaux = Pop[p].Cell[i].Threshold;

      fprintf(devtraces, "%f\t", Pop[p].Cell[i].V);
      //    for (r=0;r<Pop[p].Cell[i].Nreceptors;r++) {
      //      if (Pop[p].Cell[i].MgFlag[r]) {
      //        fprintf(devtraces,"%f\t",Pop[p].Cell[i].LS[r]);  //
      //        /(1.+exp(-0.062*Vaux)/3.57)); mg block now not included
      //      } else {
      //        fprintf(devtraces,"%f\t",Pop[p].Cell[i].LS[r]);
      //      }
      //    }
    }
  }
  fprintf(devtraces, "\n");
}


// Handle event
// -------------------------------------------------------------------------------------------------------------------

int HandleEvent(void) {
  int i, p, r, q, j;
  float efficacy, MeanEff;

  if (Events[CStage][CEvent].Type == ENDOFTRIAL) {
    if (Events[CStage][CEvent].PopNumber < 0) {
      EndingEvent = Events[CStage][CEvent];
      return 0;
    }
    // dynamic cutoff
    CCutoff++;
  }

  if (Events[CStage][CEvent].Type == RESETEXTFREQ) {
    p = Events[CStage][CEvent].PopNumber;
    r = Events[CStage][CEvent].ReceptorNumber;
    PopD[p].FreqExt[r] = Events[CStage][CEvent].FreqExt;
    // printf("%7.1f ------------------ Event: %s ----------------\n",Time,Events[CStage][CEvent].Label);

    efficacy = PopD[p].MeanExtEff[r];
    PopD[p].MeanExtMuS[r] = PopD[p].FreqExt[r] * .001 * efficacy *
                            PopD[p].MeanExtCon[r] * PopD[p].Tau[r];
    PopD[p].MeanExtSigmaS[r] =
        sqrt(PopD[p].Tau[r] * .5 * PopD[p].FreqExt[r] * .001 * efficacy *
             efficacy * PopD[p].MeanExtCon[r]);

    for (i = 0; i < Pop[p].Ncells; i++) {
      do {
        efficacy = (gasdev() * PopD[p].ExtEffSD[r]) + PopD[p].MeanExtEff[r];
      } while (efficacy < 0);
      Pop[p].Cell[i].ExtMuS[r] = PopD[p].FreqExt[r] * .001 * efficacy *
                                 PopD[p].MeanExtCon[r] * PopD[p].Tau[r];
      Pop[p].Cell[i].ExtSigmaS[r] =
          sqrt(PopD[p].Tau[r] * .5 * PopD[p].FreqExt[r] * .001 * efficacy *
               efficacy * PopD[p].MeanExtCon[r]);
    }
  }
  if (Events[CStage][CEvent].Type == CHANGEEXTFREQ) {
    p = Events[CStage][CEvent].PopNumber;
    r = Events[CStage][CEvent].ReceptorNumber;
    PopD[p].FreqExt[r] = Events[CStage][CEvent].FreqExt;
    // printf("%7.1f ------------------ Event: %s ----------------\n",Time,Events[CStage][CEvent].Label);

    efficacy = PopD[p].MeanExtEff[r];
    PopD[p].MeanExtMuS[r] = PopD[p].FreqExt[r] * .001 * efficacy *
                            PopD[p].MeanExtCon[r] * PopD[p].Tau[r];
    PopD[p].MeanExtSigmaS[r] =
        sqrt(PopD[p].Tau[r] * .5 * PopD[p].FreqExt[r] * .001 * efficacy *
             efficacy * PopD[p].MeanExtCon[r]);

    for (i = 0; i < Pop[p].Ncells; i++) {
      do {
        efficacy = (gasdev() * PopD[p].ExtEffSD[r]) + PopD[p].MeanExtEff[r];
      } while (efficacy < 0);
      Pop[p].Cell[i].ExtMuS[r] = PopD[p].FreqExt[r] * .001 * efficacy *
                                 PopD[p].MeanExtCon[r] * PopD[p].Tau[r];
      Pop[p].Cell[i].ExtSigmaS[r] =
          sqrt(PopD[p].Tau[r] * .5 * PopD[p].FreqExt[r] * .001 * efficacy *
               efficacy * PopD[p].MeanExtCon[r]);
    }
  }

  if (Events[CStage][CEvent].Type == CHANGEEXTFREQSD) {
    p = Events[CStage][CEvent].PopNumber;
    r = Events[CStage][CEvent].ReceptorNumber;
    PopD[p].FreqExtSD[r] = Events[CStage][CEvent].FreqExtSD;
    // printf("%7.1f ------------------ Event: %s ----------------\n",Time,Events[CStage][CEvent].Label);
  }

  if (Events[CStage][CEvent].Type == CHANGEMEANEFF) {
    p = Events[CStage][CEvent].PopNumber;
    q = Events[CStage][CEvent].TargetPopNumber;
    r = Events[CStage][CEvent].ReceptorNumber;
    // printf("%7.1f ------------------ Event: %s ----------------\n",Time,Events[CStage][CEvent].Label);
    MeanEff = Events[CStage][CEvent].MeanEff;
    for (i = 0; i < PopD[p].NTargetPops; i++)
      if (PopD[p].TargetPops[i] == q) {
        if (PopD[p].SynP[i].TargetReceptor == r)
          PopD[p].SynP[i].MeanEfficacy = MeanEff;
      }
    for (i = 0; i < Pop[p].Ncells; i++) {
      for (j = 0; j < Pop[p].Cell[i].Naxonals; j++)
        if ((Pop[p].Cell[i].Axonals[j].TargetPop == q) &&
            (Pop[p].Cell[i].Axonals[j].TargetReceptor == r))
          Pop[p].Cell[i].Axonals[j].Efficacy = MeanEff;
    }
  }

  CEvent++;
  NextEventTime = Events[CStage][CEvent].ETime + CStageStart;

  return 1;
}


int main(int argc, char *argv[])
{
  int ti,runflag,tistepforsaving,rseed;
  long iseed;

  iseed=-1000;
  sran1(&iseed);

  CurrentTrial=0;
  Trialnumber=0;

  flagverbose=1;
  //NumberofTrials=1;
  FlagSaveAllSpikes=1;
  //  strcpy(prefix,"cl_");

  if(argc>1) {
    do {
      if(strncmp(argv[argc-1],"-v",2)==0) {
        flagverbose=1; argc--;
        continue;
      }
      if(strncmp(argv[argc-1],"-h",2)==0) {
        printf("cl_realsimu7e_p \n Usage:\n-h  : this help\n-v  : verbose mode\n-t# : number of saved traces per population\n");
        //  printf("-T# : number of trials (the network is the same for each trial, the realization of the ext noise changes)\n");
        printf("-ns : spikes and traces are not saved. Only the mean frequencies are saved for each trial\n");
        printf("-s# : seed for the random number generator.\n");
        return -1;
      }
      if(strncmp(argv[argc-1],"-t",2)==0) {
        NumberofTraces=atoi(&argv[argc-1][2]);
        printf("Number of saved traces: %d\n",NumberofTraces);
        argc--; continue;
      }
      if(strncmp(argv[argc-1],"-s",2)==0) {
        rseed=atoi(&argv[argc-1][2]);
        //srand49(rseed); this will set the seed for srand49() to rseed, which is not necessory. the drand49 is used to construct the network connection in the sparse network.
        //by commenting this, the chance of connectivity and the gaussian number is different seeded, with the later from command line input
        iseed=-1*(long)rseed;
        sran1(&iseed);
        printf("Seed for random generator: %d\n",rseed);
        argc--; continue;
      }
      if(strncmp(argv[argc-1],"-ns",3)==0) {
        FlagSaveAllSpikes=0;
        NumberofTraces=0;
        printf("Spikes are not saved\n");
        argc--; continue;
      }
      if(strncmp(argv[argc-1],"-n",2)==0) {
        Trialnumber=atoi(&argv[argc-1][2]);
        printf("Trialnumber: %d\n",Trialnumber);
        argc--; continue;
      }
      /*
      if(strncmp(argv[argc-1],"-T",2)==0) {
        NumberofTrials=atoi(&argv[argc-1][2]);
        printf("Number of trials: %d\n",NumberofTrials);
        argc--; continue;
      }
      */
      /*
      if(strncmp(argv[argc-1],"-p",2)==0) {
        strcpy=(prefix,&argv[argc-1][2]);
        printf("Prefix to all input/output files: %s\n",prefix);
        argc--; continue;
      }
      */
      printf("ERROR: unrecognized option: %s\n",argv[argc]);
      argc--;
    } while(argc>1);
  }
  if(DescribeNetwork()==-1) {printf("Unrecoverable error in parsing the conf file, exiting...\n"); return -1;}
  if(ParseProtocol()==-1) { printf("Unrecoverable error in parsing the protocol file, exiting...\n"); return -1;}

  GenerateNetwork();

  //for(CurrentTrial=0;CurrentTrial<NumberofTrials;CurrentTrial++)
    //{
    report("Trial #\%d\n=====================================================================\n",Trialnumber);
    CEvent=0;
    // dynamic cutoff
    CCutoff=0;
    CStageStart = 0;
    CStage = 0;
    NextEventTime=Events[CStage][CEvent].ETime + CStageStart;
    runflag=1;

    //GenMatLabMultiTrial();

    //if(CurrentTrial) InitializeNetwork();

    for(ti=0,Time=0.;runflag;Time+=dt,ti++)
    {
      SimulateOneTimeStep();
      // handle all the events
      if(Time >= NextEventTime) {
        runflag = SaveSpikes(1);
        while(Time >= NextEventTime)
        {
          runflag = HandleEvent();
          if (runflag == 0) break;
        }
      } else runflag = SaveSpikes(0);

      SaveWeights();
      SaveE();
      SaveQ1();
      SaveQ2();
      SaveDpmn();
      SaveTraces();
      SaveDC();
      SaveNMDA();
      SaveAMPA();
      SaveGABA();

      if (runflag == 0 && CStage < NStages - 1) {
        CStage++;
        CStageStart = Time;
        CEvent=0;
        CCutoff=0;
        NextEventTime=Events[CStage][CEvent].ETime + CStageStart;
        if (rewardflag == 0 && EndingEvent.RewardFlag) {
          rewardflag = EndingEvent.RewardFlag;
          dpmn_RewardTime = Time + 300.0;
          if (rewardflag == 1) {
            Events[CStage][0].ETime += 300.0;
            EventDescr temp;
            temp = Events[CStage][0];
            Events[CStage][0] = Events[CStage][1];
            Events[CStage][1] = temp;
          } else if (rewardflag == 2) {
            Events[CStage][1].ETime += 300.0;
          }
        }
        runflag = 1;
        report("time %f\n", Time);
        report("reward flag %d\n", rewardflag);
        report("reward value %f\n", EndingEvent.RewardVal);
      }
    }
    report("\rEnd of the trial\n");
    //}
}
